<?php

declare(strict_types=1);

use App\Models\Chat\Conversation;
use App\Models\Chat\EncryptionKey;
use App\Models\Chat\Message;
use App\Models\User;
use App\Services\ChatEncryptionService;
use Illuminate\Foundation\Testing\RefreshDatabase;

uses(RefreshDatabase::class);

beforeEach(function () {
    $this->encryptionService = new ChatEncryptionService;
    $this->user1 = User::factory()->create();
    $this->user2 = User::factory()->create();
    $this->unauthorizedUser = User::factory()->create();

    $this->conversation = Conversation::factory()->create([
        'type' => 'direct',
        'created_by' => $this->user1->id,
    ]);

    $this->conversation->participants()->create([
        'conversation_id' => $this->conversation->id,
        'user_id' => $this->user1->id,
    ]);

    $this->conversation->participants()->create([
        'conversation_id' => $this->conversation->id,
        'user_id' => $this->user2->id,
    ]);
});

describe('E2EE Security Vulnerabilities and Attack Resistance', function () {
    describe('Authentication and Authorization', function () {
        it('prevents unauthorized message decryption', function () {
            $symmetricKey = $this->encryptionService->generateSymmetricKey();
            $unauthorizedKeyPair = $this->encryptionService->generateKeyPair();

            // Create encrypted message
            $message = Message::createEncrypted(
                $this->conversation->id,
                $this->user1->id,
                'Secret message for authorized users only',
                $symmetricKey
            );

            // Unauthorized user should not be able to decrypt
            expect(fn () => $message->decryptContent('wrong-key'))
                ->toThrow(\App\Exceptions\DecryptionException::class);

            // Even with a valid key format, wrong key should fail
            $wrongSymmetricKey = $this->encryptionService->generateSymmetricKey();
            expect(fn () => $message->decryptContent($wrongSymmetricKey))
                ->toThrow(\App\Exceptions\DecryptionException::class);
        });

        it('prevents key theft through side channels', function () {
            $keyPair1 = $this->encryptionService->generateKeyPair();
            $keyPair2 = $this->encryptionService->generateKeyPair();
            $symmetricKey = $this->encryptionService->generateSymmetricKey();

            // Encrypt the same symmetric key with different public keys
            $encryptedKey1 = $this->encryptionService->encryptSymmetricKey($symmetricKey, $keyPair1['public_key']);
            $encryptedKey2 = $this->encryptionService->encryptSymmetricKey($symmetricKey, $keyPair2['public_key']);

            // The encrypted keys should be different (no deterministic encryption)
            expect($encryptedKey1)->not()->toBe($encryptedKey2);

            // But both should decrypt to the same symmetric key
            $decrypted1 = $this->encryptionService->decryptSymmetricKey($encryptedKey1, $keyPair1['private_key']);
            $decrypted2 = $this->encryptionService->decryptSymmetricKey($encryptedKey2, $keyPair2['private_key']);

            expect($decrypted1)->toBe($symmetricKey);
            expect($decrypted2)->toBe($symmetricKey);
        });

        it('validates message integrity with HMAC', function () {
            $symmetricKey = $this->encryptionService->generateSymmetricKey();
            $originalContent = 'Integrity-protected message';

            $message = Message::createEncrypted(
                $this->conversation->id,
                $this->user1->id,
                $originalContent,
                $symmetricKey
            );

            // Get the encrypted content
            $encryptedData = json_decode($message->encrypted_content, true);

            // Tamper with the encrypted data
            $encryptedData['data'] = base64_encode('tampered_data');
            $message->encrypted_content = json_encode($encryptedData);

            // Decryption should fail due to integrity check
            expect(fn () => $message->decryptContent($symmetricKey))
                ->toThrow(\App\Exceptions\DecryptionException::class);
        });

        it('prevents replay attacks with timestamps and nonces', function () {
            $symmetricKey = $this->encryptionService->generateSymmetricKey();
            $content = 'Time-sensitive message';

            $message = Message::createEncrypted(
                $this->conversation->id,
                $this->user1->id,
                $content,
                $symmetricKey
            );

            $encryptedData = json_decode($message->encrypted_content, true);

            // Verify timestamp is recent (within last minute)
            expect($encryptedData['timestamp'])->toBeGreaterThan(time() - 60);

            // Verify nonce exists and is not empty
            expect($encryptedData['nonce'])->not()->toBeEmpty();

            // Each message should have a unique nonce
            $message2 = Message::createEncrypted(
                $this->conversation->id,
                $this->user1->id,
                $content,
                $symmetricKey
            );

            $encryptedData2 = json_decode($message2->encrypted_content, true);
            expect($encryptedData['nonce'])->not()->toBe($encryptedData2['nonce']);
        });
    });

    describe('Cryptographic Attack Resistance', function () {
        it('prevents weak key generation', function () {
            // Generate multiple keys and verify they're sufficiently random
            $keys = [];
            for ($i = 0; $i < 10; $i++) {
                $keys[] = $this->encryptionService->generateSymmetricKey();
            }

            // All keys should be different
            expect(count(array_unique($keys)))->toBe(10);

            // Keys should have proper length (32 bytes for AES-256)
            foreach ($keys as $key) {
                expect(strlen($key))->toBe(32);

                // Keys should not be all zeros or predictable patterns
                expect($key)->not()->toBe(str_repeat("\0", 32));
                expect($key)->not()->toBe(str_repeat('a', 32));
            }
        });

        it('prevents timing attacks in key comparison', function () {
            $keyPair = $this->encryptionService->generateKeyPair();
            $symmetricKey = $this->encryptionService->generateSymmetricKey();

            $encryptedKey = $this->encryptionService->encryptSymmetricKey($symmetricKey, $keyPair['public_key']);

            // Time correct decryption
            $start1 = microtime(true);
            $decrypted1 = $this->encryptionService->decryptSymmetricKey($encryptedKey, $keyPair['private_key']);
            $time1 = microtime(true) - $start1;

            // Time incorrect decryption (should still take similar time)
            $wrongKeyPair = $this->encryptionService->generateKeyPair();
            $start2 = microtime(true);

            try {
                $this->encryptionService->decryptSymmetricKey($encryptedKey, $wrongKeyPair['private_key']);
            } catch (\App\Exceptions\DecryptionException $e) {
                // Expected to fail
            }

            $time2 = microtime(true) - $start2;

            // The timing difference should not be too significant (within 50ms)
            $timeDifference = abs($time1 - $time2);
            expect($timeDifference)->toBeLessThan(0.05);

            expect($decrypted1)->toBe($symmetricKey);
        });

        it('prevents padding oracle attacks', function () {
            $symmetricKey = $this->encryptionService->generateSymmetricKey();
            $content = 'Message susceptible to padding oracle';

            $encrypted = $this->encryptionService->encryptMessage($content, $symmetricKey);

            // Try to create padding oracle by tampering with ciphertext
            $ciphertext = base64_decode($encrypted['data']);

            // Flip last byte to corrupt padding
            $corruptedCiphertext = $ciphertext;
            $corruptedCiphertext[strlen($corruptedCiphertext) - 1] = chr(ord($corruptedCiphertext[strlen($corruptedCiphertext) - 1]) ^ 1);

            $corruptedEncrypted = base64_encode($corruptedCiphertext);

            // Should fail consistently without leaking padding information
            expect(fn () => $this->encryptionService->decryptMessage(
                $corruptedEncrypted,
                $encrypted['iv'],
                $symmetricKey
            ))->toThrow(\App\Exceptions\DecryptionException::class);
        });

        it('uses secure random number generation', function () {
            $ivs = [];

            // Generate multiple IVs and verify randomness
            for ($i = 0; $i < 100; $i++) {
                $encrypted = $this->encryptionService->encryptMessage('test', $this->encryptionService->generateSymmetricKey());
                $ivs[] = $encrypted['iv'];
            }

            // All IVs should be unique
            expect(count(array_unique($ivs)))->toBe(100);

            // Check for patterns in IVs (basic randomness test)
            $concatenated = implode('', $ivs);
            $zeroCount = substr_count($concatenated, '0');
            $totalChars = strlen($concatenated);

            // Roughly 10% of base64 chars should be '0' (64 possible chars)
            $zeroRatio = $zeroCount / $totalChars;
            expect($zeroRatio)->toBeBetween(0.05, 0.20); // Allow some variance
        });
    });

    describe('Forward Secrecy and Key Rotation', function () {
        it('ensures forward secrecy after key rotation', function () {
            $oldSymmetricKey = $this->encryptionService->generateSymmetricKey();
            $newSymmetricKey = $this->encryptionService->generateSymmetricKey();
            $keyPair = $this->encryptionService->generateKeyPair();

            // Create message with old key
            $oldMessage = Message::createEncrypted(
                $this->conversation->id,
                $this->user1->id,
                'Message with old key - should remain accessible',
                $oldSymmetricKey
            );

            // Rotate key
            $oldKey = EncryptionKey::createForUser(
                $this->conversation->id,
                $this->user1->id,
                $oldSymmetricKey,
                $keyPair['public_key']
            );

            $oldKey->update(['is_active' => false]);

            $newKey = EncryptionKey::createForUser(
                $this->conversation->id,
                $this->user1->id,
                $newSymmetricKey,
                $keyPair['public_key']
            );

            // Create message with new key
            $newMessage = Message::createEncrypted(
                $this->conversation->id,
                $this->user1->id,
                'Message with new key - uses rotated key',
                $newSymmetricKey
            );

            // Old message should still be decryptable with old key
            expect($oldMessage->decryptContent($oldSymmetricKey))->toBe('Message with old key - should remain accessible');

            // New message should be decryptable with new key
            expect($newMessage->decryptContent($newSymmetricKey))->toBe('Message with new key - uses rotated key');

            // Cross-contamination should not work
            expect(fn () => $oldMessage->decryptContent($newSymmetricKey))
                ->toThrow(\App\Exceptions\DecryptionException::class);

            expect(fn () => $newMessage->decryptContent($oldSymmetricKey))
                ->toThrow(\App\Exceptions\DecryptionException::class);
        });

        it('securely deletes old key material after rotation', function () {
            $symmetricKey = $this->encryptionService->generateSymmetricKey();
            $keyPair = $this->encryptionService->generateKeyPair();

            $encryptionKey = EncryptionKey::createForUser(
                $this->conversation->id,
                $this->user1->id,
                $symmetricKey,
                $keyPair['public_key']
            );

            // Deactivate the key
            $encryptionKey->update(['is_active' => false]);

            // The encrypted key should still exist in database for old message decryption
            // But the key should be marked as inactive
            expect($encryptionKey->is_active)->toBeFalse();
        });
    });

    describe('Access Control and Privilege Escalation', function () {
        it('prevents privilege escalation through key manipulation', function () {
            $symmetricKey = $this->encryptionService->generateSymmetricKey();
            $authorizedKeyPair = $this->encryptionService->generateKeyPair();
            $unauthorizedKeyPair = $this->encryptionService->generateKeyPair();

            // Create encryption key for authorized user
            $encryptionKey = EncryptionKey::createForUser(
                $this->conversation->id,
                $this->user1->id,
                $symmetricKey,
                $authorizedKeyPair['public_key']
            );

            // Unauthorized user shouldn't be able to create keys for this conversation
            // without proper authorization (tested through model policies)
            expect($encryptionKey->user_id)->toBe($this->user1->id);
            expect($encryptionKey->conversation_id)->toBe($this->conversation->id);
        });

        it('prevents unauthorized key export/backup', function () {
            $this->actingAs($this->user1, 'api');

            // Create some encryption data
            $keyPair = $this->encryptionService->generateKeyPair();
            $this->user1->update(['public_key' => $keyPair['public_key']]);

            EncryptionKey::createForUser(
                $this->conversation->id,
                $this->user1->id,
                'test-symmetric-key',
                $this->user1->public_key
            );

            // User1 should be able to backup their own keys
            $response = $this->postJson('/api/v1/chat/encryption/backup/create', [
                'password' => 'SecureBackupPassword123!',
            ]);

            $response->assertStatus(200);
            $backupData = $response->json('backup_data');

            // Switch to unauthorized user
            $this->actingAs($this->unauthorizedUser, 'api');

            // Unauthorized user should not be able to restore another user's backup
            $restoreResponse = $this->postJson('/api/v1/chat/encryption/backup/restore', [
                'backup_data' => $backupData,
                'password' => 'SecureBackupPassword123!',
            ]);

            $restoreResponse->assertStatus(403);
        });

        it('prevents conversation hijacking through encryption keys', function () {
            $symmetricKey = $this->encryptionService->generateSymmetricKey();
            $keyPair = $this->encryptionService->generateKeyPair();

            // Create private conversation
            $privateConversation = Conversation::factory()->create([
                'type' => 'direct',
                'created_by' => $this->user1->id,
            ]);

            $privateConversation->participants()->create([
                'conversation_id' => $privateConversation->id,
                'user_id' => $this->user1->id,
            ]);

            // Only user1 should be able to create encryption keys for this conversation
            $encryptionKey = EncryptionKey::createForUser(
                $privateConversation->id,
                $this->user1->id,
                $symmetricKey,
                $keyPair['public_key']
            );

            expect($encryptionKey->user_id)->toBe($this->user1->id);
            expect($encryptionKey->conversation_id)->toBe($privateConversation->id);

            // Verify unauthorized user cannot create keys for this conversation
            $unauthorizedKeyPair = $this->encryptionService->generateKeyPair();

            try {
                EncryptionKey::createForUser(
                    $privateConversation->id,
                    $this->unauthorizedUser->id,
                    $symmetricKey,
                    $unauthorizedKeyPair['public_key']
                );

                $this->fail('Should not allow unauthorized key creation');
            } catch (\Exception $e) {
                // Expected to fail - either through database constraints or business logic
                expect(true)->toBeTrue();
            }
        });
    });

    describe('Data Leakage Prevention', function () {
        it('prevents key material leakage through error messages', function () {
            $keyPair = $this->encryptionService->generateKeyPair();
            $corruptedPrivateKey = str_replace('PRIVATE', 'CORRUPT', $keyPair['private_key']);

            try {
                $this->encryptionService->decryptSymmetricKey('encrypted-data', $corruptedPrivateKey);
                $this->fail('Should throw exception for corrupted key');
            } catch (\App\Exceptions\DecryptionException $e) {
                // Error message should not contain sensitive key material
                expect($e->getMessage())->not()->toContain($keyPair['private_key']);
                expect($e->getMessage())->not()->toContain($corruptedPrivateKey);
                expect($e->getMessage())->not()->toContain('PRIVATE KEY');
            }
        });

        it('prevents symmetric key leakage in logs', function () {
            $symmetricKey = $this->encryptionService->generateSymmetricKey();
            $content = 'Test message for logging verification';

            // Clear any existing logs
            \Log::getMonolog()->reset();

            // Perform encryption operation
            $encrypted = $this->encryptionService->encryptMessage($content, $symmetricKey);
            $decrypted = $this->encryptionService->decryptMessage($encrypted['data'], $encrypted['iv'], $symmetricKey);

            expect($decrypted)->toBe($content);

            // In a real test, we would check log files for key material
            // For now, we verify the operation completed successfully
            expect($encrypted)->toHaveKeys(['data', 'iv', 'hash']);
        });

        it('prevents memory dumps from exposing keys', function () {
            $symmetricKey = $this->encryptionService->generateSymmetricKey();

            // Perform encryption
            $encrypted = $this->encryptionService->encryptMessage('Sensitive data', $symmetricKey);

            // Overwrite the key variable (simulating secure memory handling)
            $symmetricKey = str_repeat("\0", strlen($symmetricKey));

            // The original key should not be recoverable
            expect($symmetricKey)->toBe(str_repeat("\0", 32));

            // But the encrypted data should still be valid for decryption with the real key
            $realKey = $this->encryptionService->generateSymmetricKey();
            // Note: In practice, we'd store the real key securely
        });
    });

    describe('Protocol Security', function () {
        it('validates encryption protocol versions', function () {
            $encryptionKey = EncryptionKey::factory()->create([
                'conversation_id' => $this->conversation->id,
                'user_id' => $this->user1->id,
                'key_version' => 1,
            ]);

            expect($encryptionKey->key_version)->toBeGreaterThan(0);
        });

        it('prevents downgrade attacks', function () {
            // Create current version key
            $currentKey = EncryptionKey::factory()->create([
                'conversation_id' => $this->conversation->id,
                'user_id' => $this->user1->id,
                'key_version' => 2,
                'is_active' => true,
            ]);

            // Attempting to create older version should maintain security
            $olderKey = EncryptionKey::factory()->create([
                'conversation_id' => $this->conversation->id,
                'user_id' => $this->user2->id,
                'key_version' => 1,
                'is_active' => true,
            ]);

            expect($currentKey->key_version)->toBeGreaterThan($olderKey->key_version);
        });

        it('enforces minimum encryption standards', function () {
            // Verify that all generated keys meet minimum security requirements
            $keyPair = $this->encryptionService->generateKeyPair();

            // RSA keys should be at least 2048 bits
            expect(strlen($keyPair['public_key']))->toBeGreaterThan(200);
            expect(strlen($keyPair['private_key']))->toBeGreaterThan(800);

            // Symmetric keys should be 256 bits (32 bytes)
            $symmetricKey = $this->encryptionService->generateSymmetricKey();
            expect(strlen($symmetricKey))->toBe(32);
        });
    });

    describe('Side-Channel Attack Resistance', function () {
        it('uses constant-time operations where possible', function () {
            $keyPair = $this->encryptionService->generateKeyPair();
            $symmetricKey = $this->encryptionService->generateSymmetricKey();

            // Measure time for successful operations
            $times = [];
            for ($i = 0; $i < 5; $i++) {
                $encryptedKey = $this->encryptionService->encryptSymmetricKey($symmetricKey, $keyPair['public_key']);

                $start = microtime(true);
                $decrypted = $this->encryptionService->decryptSymmetricKey($encryptedKey, $keyPair['private_key']);
                $times[] = microtime(true) - $start;

                expect($decrypted)->toBe($symmetricKey);
            }

            // Operations should have relatively consistent timing
            $avgTime = array_sum($times) / count($times);
            foreach ($times as $time) {
                // Each operation should be within 50% of average time
                expect($time)->toBeBetween($avgTime * 0.5, $avgTime * 1.5);
            }
        });

        it('prevents cache timing attacks', function () {
            // Generate different keys with different characteristics
            $keys = [];
            for ($i = 0; $i < 10; $i++) {
                $keys[] = $this->encryptionService->generateSymmetricKey();
            }

            // Operations should not leak information through cache timing
            foreach ($keys as $key) {
                $content = "Test message {$i}";
                $start = microtime(true);
                $encrypted = $this->encryptionService->encryptMessage($content, $key);
                $encryptionTime = microtime(true) - $start;

                $start = microtime(true);
                $decrypted = $this->encryptionService->decryptMessage($encrypted['data'], $encrypted['iv'], $key);
                $decryptionTime = microtime(true) - $start;

                expect($decrypted)->toBe($content);

                // Times should be reasonable (not indicating cache misses/hits)
                expect($encryptionTime)->toBeLessThan(1.0);
                expect($decryptionTime)->toBeLessThan(1.0);
            }
        });
    });
});
